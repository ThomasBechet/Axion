#version 420 core

layout(location = 0) out vec4 out_albedo_specular;
layout(location = 1) out vec4 out_normal_depth;

in vec2 UV;
in vec3 Normal;
in vec3 Color;

#define USE_MATERIAL_UNIFORM_BLOCK 1 
#if USE_MATERIAL_UNIFORM_BLOCK

	#define MATERIAL_MAX_NUMBER 50
	#define MATERIAL_BINDING_POINT 1
	#define MATERIAL_USE_DIFFUSE_TEXTURE 1
	#define MATERIAL_USE_NORMAL_TEXTURE 2
	#define MATERIAL_IS_BUMP_TEXTURE 4
	#define MATERIAL_USE_SPECULAR_TEXTURE 8

	struct Material
	{
		uint flags;
		vec4 diffuse_color;
	};
	layout(std140, binding = MATERIAL_BINDING_POINT) uniform Materials
	{
		Material materials[MATERIAL_MAX_NUMBER];	
	};

	layout(binding = 0) uniform sampler2D diffuse_texture;
	layout(binding = 1) uniform sampler2D normal_texture;
	layout(binding = 2) uniform sampler2D specular_texture;

	uniform uint material_index;
#endif

void main()
{
	//Albedo
	if(bool(materials[material_index].flags & MATERIAL_USE_DIFFUSE_TEXTURE))
	{
		out_albedo_specular.rgb = texture(diffuse_texture, vec2(UV.x, 1.0 - UV.y)).rgb;
	}
	else
	{
		out_albedo_specular.rgb = materials[material_index].diffuse_color.rgb;
	}

	//Normal	
	if(bool(materials[material_index].flags & MATERIAL_USE_NORMAL_TEXTURE))
	{
		if(bool(materials[material_index].flags & MATERIAL_IS_BUMP_TEXTURE))
		{
			out_normal_depth.rgb = vec3(texture(normal_texture, vec2(UV.x, 1.0 - UV.y)).r, 0.0f, 0.0f);
		}	
		else
		{
			out_normal_depth.rgb = (texture(normal_texture, vec2(UV.x, 1.0 - UV.y)).rgb * 2.0) - 1.0;
		}
	}
	else
	{
		out_normal_depth.rgb = Normal;
	}

	//Depth
	out_normal_depth.a = gl_FragCoord.z;
}