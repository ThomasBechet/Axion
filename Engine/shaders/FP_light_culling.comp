#version 430

#define USE_CAMERA 1
#if USE_CAMERA

	#define CAMERA_UBO_BINDING_POINT 2

	layout(std140, binding = CAMERA_UBO_BINDING_POINT) uniform Camera
	{
		mat4 camera_projection;
		mat4 camera_view;
		mat4 inv_camera_projection;
	};

#endif

#define USE_POINTLIGHT 1 
#if USE_POINTLIGHT

	#define POINTLIGHT_UBO_BINDING_POINT 3
	#define POINTLIGHT_MAX_NUMBER 500

	struct PointLight
	{
		vec3 position;
		float radius;
		vec3 color;
		float intensity;
	};
	layout(std140, binding = POINTLIGHT_UBO_BINDING_POINT) uniform PointLights
	{ 
		PointLight point_lights[POINTLIGHT_MAX_NUMBER];
		uint point_light_count;
	};

#endif

#define USE_POINTLIGHT_CULLING 1
#if USE_POINTLIGHT_CULLING

    #define POINTLIGHT_CULL_SSBO_BINDING_POINT 5
	#define POINTLIGHT_CULL_MAX_NUMBER 1024
	#define CULL_TILE_SIZE 16

    layout(packed, binding = POINTLIGHT_CULL_SSBO_BINDING_POINT) writeonly buffer PointLightsCullIndices
    {
        int point_lights_cull_indices[];
    };

#endif

shared ivec2 screenSize;
shared uint minDepthUint;
shared uint maxDepthUint;
shared uint visibleLightCount;
shared int visibleLightIndices[POINTLIGHT_CULL_MAX_NUMBER];

shared vec4 frustumPlanes[6];

layout(binding = 0) uniform sampler2D depth_texture;

vec4 unProject(vec4 clipSpace)
{
	vec4 homo = inv_camera_projection * clipSpace;
	homo.xyz /= homo.w;
	return homo;
}

layout(local_size_x = CULL_TILE_SIZE, local_size_y = CULL_TILE_SIZE, local_size_z = 1) in;
void main()
{
    ivec2 globalID = ivec2(gl_GlobalInvocationID.xy);
	ivec2 localID = ivec2(gl_LocalInvocationID.xy);
	ivec2 tileID = ivec2(gl_WorkGroupID.xy);
	ivec2 tileNumber = ivec2(gl_NumWorkGroups.xy);
    uint index = tileID.y * tileNumber.x + tileID.x;

    // Initialize shared global values for depth and light count
	if(gl_LocalInvocationIndex == 0)
	{
		screenSize = textureSize(depth_texture, 0);
		minDepthUint = 0x0u;
		maxDepthUint = 0xFFFFFFFFu;
		visibleLightCount = 0;
	}

	barrier();

	//Compute max and min depth per tile
	vec2 uv = vec2(globalID) / screenSize;
	float depth = texture(depth_texture, uv).r;
	
	uint depthUint = floatBitsToUint(depth);
	atomicMin(minDepthUint, depthUint);
	atomicMax(maxDepthUint, depthUint);

	barrier();

	float maxDepth = uintBitsToFloat(maxDepthUint);
	float minDepth = uintBitsToFloat(minDepthUint);

	uint minX = MAX_WORK_GROUP_SIZE * gl_WorkGroupID.x;
	uint minY = MAX_WORK_GROUP_SIZE * gl_WorkGroupID.y;
	uint maxX = MAX_WORK_GROUP_SIZE * (gl_WorkGroupID.x + 1);
	uint maxY = MAX_WORK_GROUP_SIZE * (gl_WorkGroupID.y + 1);

	if(gl_LocalInvocationIndex == 0)
	{
		for (uint i = 0; i < point_light_count; i++)
		{
			vec4 position = vec4(point_lights[i].position, 1.0f); //view space
			float radius = point_lights[i].radius;

			vec4 near = vec4(0.0f, 0.0f, maxDepth, 1.0f);
			near *= inv_camera_projection;
			near /= near.w;

			vec4 far = vec4(0.0f, 0.0f, minDepth, 1.0f);
			far *= inv_camera_projection;
			far /= far.w;

			if(position.z - radius < near.z && position.z - radius > far.z)
			{
				// Add index to the shared array of visible indices
				uint offset = atomicAdd(visibleLightCount, 1);
				visibleLightIndices[offset] = int(i);
			}
		}
	}

	barrier();

	// One thread should fill the global light buffer
	if(gl_LocalInvocationIndex == 0) 
	{
		uint offset = index * POINTLIGHT_CULL_MAX_NUMBER;
		for(uint i = 0; i < visibleLightCount; i++)
		{
			point_lights_cull_indices[offset + i] = visibleLightIndices[i];
		}

		if(visibleLightCount != POINTLIGHT_CULL_MAX_NUMBER) 
		{
			point_lights_cull_indices[offset + visibleLightCount] = -1;
		}
	}
}