#version 430

#define USE_CAMERA 1
#if USE_CAMERA

	#define CAMERA_UBO_BINDING_POINT 2

	layout(std140, binding = CAMERA_UBO_BINDING_POINT) uniform Camera
	{
		mat4 camera_projection;
		mat4 camera_view;
		mat4 inv_camera_projection;
	};

#endif

#define USE_POINTLIGHT 1 
#if USE_POINTLIGHT

	#define POINTLIGHT_UBO_BINDING_POINT 3
	#define POINTLIGHT_MAX_NUMBER 50

	struct PointLight
	{
		vec3 position;
		float radius;
		vec3 color;
		float intensity;
	};
	layout(std140, binding = POINTLIGHT_UBO_BINDING_POINT) uniform PointLights
	{ 
		PointLight point_lights[POINTLIGHT_MAX_NUMBER];
		uint point_light_count;
	};

#endif

#define USE_POINTLIGHT_CULLING 1
#if USE_POINTLIGHT_CULLING

    #define POINTLIGHT_CULL_SSBO_BINDING_POINT 5
	#define POINTLIGHT_CULL_MAX_NUMBER 1024
	#define CULL_TILE_SIZE 16

    layout(packed, binding = POINTLIGHT_CULL_SSBO_BINDING_POINT) writeonly buffer PointLightsCullIndices
    {
        int point_lights_cull_indices[];
    };

#endif

shared int minDepthInt;
shared int maxDepthInt;
shared uint visibleLightCount;
shared vec4 frustumPlanes[6];
shared int visibleLightIndices[POINTLIGHT_CULL_MAX_NUMBER];
shared mat4 viewProjection;
shared ivec2 screenSize;

layout(binding = 0) uniform sampler2D depth_texture;

layout(local_size_x = CULL_TILE_SIZE, local_size_y = CULL_TILE_SIZE, local_size_z = 1) in;
void main()
{
    ivec2 globalID = ivec2(gl_GlobalInvocationID.xy);
	ivec2 localID = ivec2(gl_LocalInvocationID.xy);
	ivec2 tileID = ivec2(gl_WorkGroupID.xy);
	ivec2 tileNumber = ivec2(gl_NumWorkGroups.xy);
    uint index = tileID.y * tileNumber.x + tileID.x;

    // Initialize shared global values for depth and light count
	if(gl_LocalInvocationIndex == 0)
	{
		minDepthInt = 0;
		maxDepthInt = 0xFFFFFFFF;
		visibleLightCount = 0;
		viewProjection = camera_projection * camera_view;
		screenSize = textureSize(depth_texture, 0);
	}

	barrier();

	//Compute max and min depth per tile
	float maxDepth, minDepth;
	vec2 uv = vec2(globalID) / screenSize;
	float depth = texture(depth_texture, uv).r;
	
	int depthInt = floatBitsToInt(depth);
	atomicMin(minDepthInt, depthInt);
	atomicMax(maxDepthInt, depthInt);

	//Convert back int depth to fload depth
	if (gl_LocalInvocationIndex == 0){
		minDepth = intBitsToFloat(minDepthInt);
		maxDepth = intBitsToFloat(maxDepthInt);
	}

	barrier();

	if(gl_LocalInvocationIndex == 0)
	{
		frustumPlanes[4] = vec4(0.0, 0.0, 0.0, 1.0f - maxDepth); // Near
		frustumPlanes[5] = vec4(0.0, 0.0, 1.0, maxDepth); // Far

		for (uint i = 0; i < point_light_count; i++)
		{
			vec4 position = vec4(point_lights[i].position, 1.0f); //view space
			float radius = point_lights[i].radius;

			//PASSER EN VIEW SPACE OBLIGER (radius)
			position *= camera_projection;
			position.z /= position.w;
			if(position.z > maxDepth)
			{
				// Add index to the shared array of visible indices
				uint offset = atomicAdd(visibleLightCount, 1);
				visibleLightIndices[offset] = int(i);
			}
		}
	}

	barrier();

	// One thread should fill the global light buffer
	if(gl_LocalInvocationIndex == 0) 
	{
		uint offset = index * POINTLIGHT_CULL_MAX_NUMBER;
		for(uint i = 0; i < visibleLightCount; i++)
		{
			point_lights_cull_indices[offset + i] = visibleLightIndices[i];
		}

		if(visibleLightCount != POINTLIGHT_CULL_MAX_NUMBER) 
		{
			point_lights_cull_indices[offset + visibleLightCount] = -1;
		}
	}
}