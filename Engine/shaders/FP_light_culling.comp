#version 430

#include GLOBAL_CONSTANTS

struct ShaderConstant
{
    ivec2 resolution;
    vec3 background_color;
};
layout(std140, binding = SGC_SHADER_CONSTANTS_UBO_BINDING_POINT) uniform ShaderConstants
{
    ShaderConstant shader_constants;
};	

layout(std140, binding = SGC_CAMERA_UBO_BINDING_POINT) uniform Camera
{
    mat4 camera_projection;
    mat4 camera_view;
    mat4 inv_camera_projection;
};

struct PointLight
{
    vec3 position;
    float radius;
    vec3 color;
    float intensity;
};
layout(std140, binding = SGC_POINTLIGHT_UBO_BINDING_POINT) uniform PointLights
{ 
    PointLight point_lights[SGC_POINTLIGHT_MAX_NUMBER];
    uint point_light_count;
};

layout(packed, binding = SGC_POINTLIGHT_CULL_SSBO_BINDING_POINT) writeonly buffer PointLightsCullIndices
{
    int point_lights_cull_indices[];
};

shared ivec2 screenSize;
shared uint minDepthUint;
shared uint maxDepthUint;
shared uint visibleLightCount;
shared int visibleLightIndices[SGC_POINTLIGHT_CULL_MAX_NUMBER];

layout(binding = 0) uniform sampler2D depth_texture;

vec4 unProject(vec4 clipSpace)
{
	vec4 homo = inv_camera_projection * clipSpace;
	homo.xyz /= homo.w;
	homo.w = 0.0f;
	return homo;
}

vec4 createPlaneEquation(vec4 b, vec4 c)
{
	vec4 n;
	n.xyz = normalize(cross(b.xyz, c.xyz));
	n.w = 0;

	return n;
}

layout(local_size_x = SGC_CULL_TILE_SIZE, local_size_y = SGC_CULL_TILE_SIZE, local_size_z = 1) in;
void main()
{
    ivec2 globalID = ivec2(gl_GlobalInvocationID.xy);
	ivec2 localID = ivec2(gl_LocalInvocationID.xy);
	ivec2 tileID = ivec2(gl_WorkGroupID.xy);
	ivec2 tileNumber = ivec2(gl_NumWorkGroups.xy);
    uint index = tileID.y * tileNumber.x + tileID.x;

    // Initialize shared global values for depth and light count
	if(gl_LocalInvocationIndex == 0)
	{
		screenSize = textureSize(depth_texture, 0);
		minDepthUint = 0x0u;
		maxDepthUint = 0xFFFFFFFFu;
		visibleLightCount = 0;
	}

	barrier();

	//Compute max and min depth per tile
	vec2 uv = vec2(globalID) / screenSize;
	float depth = texture(depth_texture, uv).r;
	
	uint depthUint = floatBitsToUint(depth);
	atomicMin(minDepthUint, depthUint);
	atomicMax(maxDepthUint, depthUint);

	barrier();

	if(gl_LocalInvocationIndex == 0)
	{
		float maxDepth = uintBitsToFloat(maxDepthUint);
		float minDepth = uintBitsToFloat(minDepthUint);

		float minX = (float(tileID.x) / float(SGC_CULL_TILE_SIZE) * 2.0f) - 1.0f;
		float minY = (float(tileID.y) / float(SGC_CULL_TILE_SIZE) * 2.0f) - 1.0f;
		float maxX = ((float(tileID.x) + 1.0f) / float(SGC_CULL_TILE_SIZE) * 2.0f) - 1.0f;
		float maxY = ((float(tileID.y) + 1.0f) / float(SGC_CULL_TILE_SIZE) * 2.0f) - 1.0f;

		vec4 corners[4];
		// 3-------2
		// |       |
		// |       |
		// 0-------1
		corners[0] = normalize(unProject(vec4(minX, minY, 1.0f, 1.0f)));
		corners[1] = normalize(unProject(vec4(maxX, minY, 1.0f, 1.0f)));
		corners[2] = normalize(unProject(vec4(maxX, maxY, 1.0f, 1.0f)));
		corners[3] = normalize(unProject(vec4(minX, maxY, 1.0f, 1.0f)));
		
		vec4 frustum[4];
		frustum[0] = createPlaneEquation(corners[0], corners[1]); //Bottom
		frustum[1] = createPlaneEquation(corners[2], corners[3]); //Up
		frustum[2] = createPlaneEquation(corners[3], corners[0]); //Left
		frustum[3] = createPlaneEquation(corners[1], corners[2]); //Right

		for(uint i = 0; i < point_light_count; i++)
		{
			vec4 position = vec4(point_lights[i].position, 1.0f); //view space
			float radius = point_lights[i].radius;

			bool inside = true;
			for(int f = 0; f < 4; f++)
			{
				if(dot(frustum[f].xyz, position.xyz) > radius)
				{
					inside = false;
					break;
				}
			}
		
			if(inside)
			{
				uint offset = atomicAdd(visibleLightCount, 1);
				visibleLightIndices[offset] = int(i);
			}
		}
	}

	barrier();

	// One thread should fill the global light buffer
	if(gl_LocalInvocationIndex == 0) 
	{
		uint offset = index * SGC_POINTLIGHT_CULL_MAX_NUMBER;
		for(uint i = 0; i < visibleLightCount; i++)
		{
			point_lights_cull_indices[offset + i] = visibleLightIndices[i];
		}

		if(visibleLightCount != SGC_POINTLIGHT_CULL_MAX_NUMBER) 
		{
			point_lights_cull_indices[offset + visibleLightCount] = -1;
		}
	}
}