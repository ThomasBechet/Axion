#version 430

#include GLOBAL_CONSTANTS

struct ShaderConstant
{
    ivec2 resolution;
};
layout(std140, binding = SGC_SHADER_CONSTANTS_UBO_BINDING_POINT) uniform ShaderConstants
{
    ShaderConstant shader_constants;
};	

layout(std140, binding = SGC_CAMERA_UBO_BINDING_POINT) uniform Camera
{
    mat4 camera_projection;
    mat4 camera_view;
    mat4 inv_camera_projection;
};

struct PointLight
{
    vec3 position;
    float radius;
    vec3 color;
    float intensity;
};
layout(std140, binding = SGC_POINTLIGHT_UBO_BINDING_POINT) uniform PointLights
{ 
    PointLight point_lights[SGC_POINTLIGHT_MAX_NUMBER];
    uint point_light_count;
};

layout(packed, binding = SGC_POINTLIGHT_CULL_SSBO_BINDING_POINT) writeonly buffer PointLightsCullIndices
{
    int point_lights_cull_indices[];
};

shared uint minDepthUint;
shared uint maxDepthUint;
shared uint visibleLightCount;
shared int visibleLightIndices[SGC_POINTLIGHT_CULL_MAX_NUMBER];

layout(binding = 0) uniform sampler2D depth_texture;

layout(local_size_x = SGC_CULL_TILE_SIZE, local_size_y = SGC_CULL_TILE_SIZE, local_size_z = 1) in;
void main()
{
    // Initialize shared global values for depth and light count
	if(gl_LocalInvocationIndex == 0)
	{
		minDepthUint = 0x0u;
		maxDepthUint = 0xFFFFFFFFu;
		visibleLightCount = 0;
	}

	barrier();

	//Compute max and min depth per tile
	vec2 uv = vec2(gl_GlobalInvocationID.xy) / shader_constants.resolution;
	float depth = texture(depth_texture, uv).r;
	
	uint depthUint = floatBitsToUint(depth);
	atomicMin(minDepthUint, depthUint);
	atomicMax(maxDepthUint, depthUint);

	barrier();

	if(gl_LocalInvocationIndex == 0)
	{
		float maxDepth = uintBitsToFloat(maxDepthUint);
		float minDepth = uintBitsToFloat(minDepthUint);

		vec2 tileScale = vec2(shader_constants.resolution * (1.0f / float(2 * SGC_CULL_TILE_SIZE)));
		vec2 tileBias = tileScale - vec2(gl_WorkGroupID.xy);

		vec4 col1 = vec4(-camera_projection[0][0] * tileScale.x, camera_projection[0][1], tileBias.x, camera_projection[0][3]);
		vec4 col2 = vec4(camera_projection[1][0], -camera_projection[1][1] * tileScale.y, tileBias.y, camera_projection[1][3]);
		vec4 col4 = vec4(camera_projection[3][0], camera_projection[3][1], -1.0f, camera_projection[3][3]);

		vec4 frustum[4];
		frustum[0] = col4 + col1;
    	frustum[1] = col4 - col1;
    	frustum[2] = col4 - col2;
    	frustum[3] = col4 + col2;
		for(int i = 0; i < 4; i++)
		{
			frustum[i] *= 1.0f / length(frustum[i].xyz);
		}

		for(uint i = 0; i < point_light_count; i++)
		{
			vec4 position = vec4(point_lights[i].position, 1.0f); //view space
			float radius = point_lights[i].radius;

			bool inFrustum = true;
            for(int i = 3; i >= 0 && inFrustum; i--)
            {
                float dist = dot(frustum[i], position);
                inFrustum = (-radius <= dist);
            }

            if(inFrustum)
            {
                uint offset = atomicAdd(visibleLightCount, 1);
				visibleLightIndices[offset] = int(i);
            }
		}
	}

	barrier();

	// One thread should fill the global light buffer
	if(gl_LocalInvocationIndex == 0) 
	{
		uint index = gl_WorkGroupID.y * gl_NumWorkGroups.x + gl_WorkGroupID.x;
		uint offset = index * SGC_POINTLIGHT_CULL_MAX_NUMBER;
		for(uint i = 0; i < visibleLightCount; i++)
		{
			point_lights_cull_indices[offset + i] = visibleLightIndices[i];
		}

		if(visibleLightCount != SGC_POINTLIGHT_CULL_MAX_NUMBER) 
		{
			point_lights_cull_indices[offset + visibleLightCount] = -1;
		}
	}
}