#version 430

#define USE_CAMERA 1
#if USE_CAMERA

	#define CAMERA_UBO_BINDING_POINT 2

	layout(std140, binding = CAMERA_UBO_BINDING_POINT) uniform Camera
	{
		mat4 camera_projection;
		mat4 camera_view;
		mat4 inv_camera_projection;
	};

#endif

#define USE_POINTLIGHT 1 
#if USE_POINTLIGHT

	#define POINTLIGHT_UBO_BINDING_POINT 3
	#define POINTLIGHT_MAX_NUMBER 500

	struct PointLight
	{
		vec3 position;
		float radius;
		vec3 color;
		float intensity;
	};
	layout(std140, binding = POINTLIGHT_UBO_BINDING_POINT) uniform PointLights
	{ 
		PointLight point_lights[POINTLIGHT_MAX_NUMBER];
		uint point_light_count;
	};

#endif

#define USE_POINTLIGHT_CULLING 1
#if USE_POINTLIGHT_CULLING

    #define POINTLIGHT_CULL_SSBO_BINDING_POINT 5
	#define POINTLIGHT_CULL_MAX_NUMBER 1024
	#define CULL_TILE_SIZE 16

    layout(packed, binding = POINTLIGHT_CULL_SSBO_BINDING_POINT) writeonly buffer PointLightsCullIndices
    {
        int point_lights_cull_indices[];
    };

#endif

shared ivec2 screenSize;
shared uint minDepthUint;
shared uint maxDepthUint;
shared uint visibleLightCount;
shared int visibleLightIndices[POINTLIGHT_CULL_MAX_NUMBER];

shared vec4 frustumPlanes[6];

layout(binding = 0) uniform sampler2D depth_texture;

vec4 unProject(vec4 clipSpace)
{
	vec4 homo = inv_camera_projection * clipSpace;
	homo.xyz *= 1.0f / homo.w;
	return homo;
}

vec4 createPlaneEquation(vec4 b, vec4 c)
{
	vec4 n;
	n.xyz = normalize(cross(b.xyz, c.xyz));
	n.w = 0;

	return n;
}

float getSignedDistanceFromPlane(vec4 p, vec4 eqn)
{
    // dot( eqn.xyz, p.xyz ) + eqn.w, , except we know eqn.w is zero 
    // (see CreatePlaneEquation above)
    return dot(eqn.xyz, p.xyz);
}

layout(local_size_x = CULL_TILE_SIZE, local_size_y = CULL_TILE_SIZE, local_size_z = 1) in;
void main()
{
    ivec2 globalID = ivec2(gl_GlobalInvocationID.xy);
	ivec2 localID = ivec2(gl_LocalInvocationID.xy);
	ivec2 tileID = ivec2(gl_WorkGroupID.xy);
	ivec2 tileNumber = ivec2(gl_NumWorkGroups.xy);
    uint index = tileID.y * tileNumber.x + tileID.x;

    // Initialize shared global values for depth and light count
	if(gl_LocalInvocationIndex == 0)
	{
		screenSize = textureSize(depth_texture, 0);
		minDepthUint = 0x0u;
		maxDepthUint = 0xFFFFFFFFu;
		visibleLightCount = 0;
	}

	barrier();

	//Compute max and min depth per tile
	vec2 uv = vec2(globalID) / screenSize;
	float depth = texture(depth_texture, uv).r;
	
	uint depthUint = floatBitsToUint(depth);
	atomicMin(minDepthUint, depthUint);
	atomicMax(maxDepthUint, depthUint);

	barrier();

	if(gl_LocalInvocationIndex == 0)
	{
		float maxDepth = uintBitsToFloat(maxDepthUint);
		float minDepth = uintBitsToFloat(minDepthUint);

		//float minX = (float(CULL_TILE_SIZE * gl_WorkGroupID.x) / screenSize.x) * 2.0f - 1.0f;
		//float minY = (float(CULL_TILE_SIZE * gl_WorkGroupID.y) / screenSize.y) * 2.0f - 1.0f;
		//float maxX = (float(CULL_TILE_SIZE * (gl_WorkGroupID.x + 1)) / screenSize.x) * 2.0f - 1.0f;
		//float maxY = (float(CULL_TILE_SIZE * (gl_WorkGroupID.y + 1)) / screenSize.y) * 2.0f - 1.0f;

		float minX = (gl_WorkGroupID.x / float(CULL_TILE_SIZE)) * 2.0f - 1.0f;
		float minY = (gl_WorkGroupID.y / float(CULL_TILE_SIZE)) * 2.0f - 1.0f;
		float maxX = (gl_WorkGroupID.x / float(CULL_TILE_SIZE + 1)) * 2.0f - 1.0f;
		float maxY = (gl_WorkGroupID.y / float(CULL_TILE_SIZE + 1)) * 2.0f - 1.0f;

		vec4 frustum[4];
		frustum[0] = unProject(vec4(minX, minY, 1.0f, 1.0f));
		frustum[1] = unProject(vec4(maxX, minY, 1.0f, 1.0f));
		frustum[2] = unProject(vec4(maxX, maxY, 1.0f, 1.0f));
		frustum[3] = unProject(vec4(minX, maxY, 1.0f, 1.0f));
		for(int i = 0; i < 4; i++) frustum[i] = createPlaneEquation(frustum[i], frustum[(i + 1) & 3]);

		for(uint i = 0; i < point_light_count; i++)
		{
			vec4 position = vec4(point_lights[i].position, 1.0f); //view space
			float radius = point_lights[i].radius;

			if( ( getSignedDistanceFromPlane( position, frustum[0] ) < radius ) &&
                ( getSignedDistanceFromPlane( position, frustum[1] ) < radius ) &&
                ( getSignedDistanceFromPlane( position, frustum[2] ) < radius ) &&
                ( getSignedDistanceFromPlane( position, frustum[3] ) < radius) )

                {
                    uint offset = atomicAdd(visibleLightCount, 1);
					visibleLightIndices[offset] = int(i);
                }
		}
	}

	barrier();

	// One thread should fill the global light buffer
	if(gl_LocalInvocationIndex == 0) 
	{
		uint offset = index * POINTLIGHT_CULL_MAX_NUMBER;
		for(uint i = 0; i < visibleLightCount; i++)
		{
			point_lights_cull_indices[offset + i] = visibleLightIndices[i];
		}

		if(visibleLightCount != POINTLIGHT_CULL_MAX_NUMBER) 
		{
			point_lights_cull_indices[offset + visibleLightCount] = -1;
		}
	}
}