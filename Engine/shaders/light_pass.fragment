#version 420 core

layout(location = 0) out vec3 out_color;

layout(binding = 0) uniform sampler2D gbuffer_albedo_specular;
layout(binding = 1) uniform sampler2D gbuffer_normal;
layout(binding = 2) uniform sampler2D gbuffer_depth_stencil;

in vec2 UV;

#define USE_POINTLIGHT_UNIFORM_BLOCK 1 
#if USE_POINTLIGHT_UNIFORM_BLOCK

	#define POINTLIGHT_MAX_NUMBER 50
	#define POINTLIGHT_BINDING_POINT 2

	struct PointLight
	{
		vec4 color;
		float radius;
		float intensity;
	};
	layout(std140, binding = POINTLIGHT_BINDING_POINT) uniform PointLights
	{
		PointLight point_lights[POINTLIGHT_MAX_NUMBER];	
	};

	uniform uint pointlight_index;
	uniform vec3 pointlight_position;
#endif

#define USE_CAMERA_UNIFORM_BLOCK 1
#if USE_CAMERA_UNIFORM_BLOCK

	#define CAMERA_BINDING_POINT 3

	layout(std140, binding = CAMERA_BINDING_POINT) uniform Camera
	{
		mat4 camera_view;
		mat4 inv_camera_projection;
	};

#endif

vec3 viewPosFromDepth(float depth)
{
    float z = depth * 2.0 - 1.0;

    vec4 clipSpacePosition = vec4(UV * 2.0 - 1.0, z, 1.0);
    vec4 viewSpacePosition = inv_camera_projection * clipSpacePosition;

    //Perspective division
    viewSpacePosition /= viewSpacePosition.w;

    return viewSpacePosition.xyz;
}

mat3 cotangent_frame( vec3 N, vec3 p, vec2 uv )
{
    // get edge vectors of the pixel triangle
    vec3 dp1 = dFdx( p );
    vec3 dp2 = dFdy( p );
    vec2 duv1 = dFdx( uv );
    vec2 duv2 = dFdy( uv );

    // solve the linear system
    vec3 dp2perp = cross( dp2, N );
    vec3 dp1perp = cross( N, dp1 );
    vec3 T = dp2perp * duv1.x + dp1perp * duv2.x;
    vec3 B = dp2perp * duv1.y + dp1perp * duv2.y;

    // construct a scale-invariant frame 
    float invmax = inversesqrt( max( dot(T,T), dot(B,B) ) );
    return mat3( T * invmax, B * invmax, N );
}

void main()
{
	vec3 albedo = texture2D(gbuffer_albedo_specular, UV).rgb;
	vec3 normal = texture2D(gbuffer_normal, UV).rgb;
	vec3 fragPos = viewPosFromDepth(texture2D(gbuffer_depth_stencil, UV).r);

	vec3 lightPos = vec3(0.0f, 0.0f, -2.0f);
	//lightPos = vec3(camera_view * vec4(lightPos, 1.0f));
	float ambientStrength = 0.0f;

	vec3 n = normalize(normal);
	vec3 l = normalize(lightPos - fragPos);

	float diffuse = max(dot(n, l), 0.0f);
	vec3 ambient = albedo * ambientStrength;

	vec3 color = (diffuse * albedo) + ambient;
	out_color = color;
}