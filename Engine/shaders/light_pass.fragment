#version 420 core

layout(location = 0) out vec3 out_color;

layout(binding = 0) uniform sampler2D gbuffer_albedo_specular;
layout(binding = 1) uniform sampler2D gbuffer_normal;
layout(binding = 2) uniform sampler2D gbuffer_depth_stencil;

in vec2 UV;

#define USE_POINTLIGHT_UNIFORM_BLOCK 1 
#if USE_POINTLIGHT_UNIFORM_BLOCK

	#define POINTLIGHT_MAX_NUMBER 50
	#define POINTLIGHT_BINDING_POINT 2

	struct PointLight
	{
		vec4 color;
		float radius;
		float intensity;
	};
	layout(std140, binding = POINTLIGHT_BINDING_POINT) uniform PointLights
	{
		PointLight point_lights[POINTLIGHT_MAX_NUMBER];	
	};

	uniform uint pointlight_index;
	uniform vec3 pointlight_position;
#endif

#define USE_CAMERA_UNIFORM_BLOCK 1
#if USE_CAMERA_UNIFORM_BLOCK

	#define CAMERA_BINDING_POINT 3

	layout(std140, binding = CAMERA_BINDING_POINT) uniform Camera
	{
		mat4 camera_view;
		mat4 camera_projection;
		mat4 inv_camera_view;
		mat4 inv_camera_projection;
	};

#endif

vec3 viewPosFromDepth(float depth)
{
    float z = depth * 2.0 - 1.0;

    vec4 clipSpacePosition = vec4(UV * 2.0 - 1.0, z, 1.0);
    vec4 viewSpacePosition = inv_camera_projection * clipSpacePosition;

    //Perspective division
    viewSpacePosition /= viewSpacePosition.w;

    return viewSpacePosition.xyz;
}

void main()
{
	vec3 albedo = texture2D(gbuffer_albedo_specular, UV).rgb;
	vec3 normal = texture2D(gbuffer_normal, UV).rgb;
	vec3 fragPos = viewPosFromDepth(texture2D(gbuffer_depth_stencil, UV).r);

	vec3 lightPos = vec3(0.0f, 5.0f, 0.0f);
	lightPos = vec3(camera_view * vec4(lightPos, 1.0f));
	float ambientStrength = 0.0f;

	vec3 n = normalize(normal);
	vec3 l = normalize(lightPos - fragPos);

	if(length(lightPos - fragPos) < 30.0f)
	{
		float diffuse = max(dot(n, l), 0.0f);
		vec3 ambient = albedo * ambientStrength;

		vec3 color = (diffuse * albedo) + ambient;
		out_color = color;
	}
	else
	{
		out_color = vec3(0, 0, 0);
	}
}